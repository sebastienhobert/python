27/07/2024

# raise exception
number = 10
if number > 5:
    raise Exception(f"The number should not exceed 5. ({number=})")
print(number)

26/07/2024

# casting
x = int(2.8) # x will be 2
y = int("3") # y will be 3
print(x)
print(y)

24/07/2024

# match statement
def runMatch():
    num = int(input("Enter a number between 1 and 3: "))

    # match case
    match num:
        case 1:
            print("One")
        case 2:
            print("Two")
        case 3:
            print("Three")
        # default pattern
        case _:
            print("Number not between 1 and 3")

runMatch()

23/07/2024

# Read CSV files but ignore any whitespace immediately following the delimiter (comma by default)
import csv
with open('people.csv', 'r') as csvfile:
    reader = csv.reader(csvfile, skipinitialspace=True)
    for row in reader:
        print(row)

22/07/2024

# Read CSV file having tab delimiter
import csv
with open("person.csv", "r") as file:
    reader = csv.reader(file, delimiter = "\t")
    for row in reader:
        print(row)

21/07/2024

# Read CSV files with csv.reader()
import csv
with open("person.csv", "r") as file:
    reader = csv.reader(file)
    for row in reader:
        print(row)

20/07/2024

# Writing to CSV files using pandas
# (1) Creating a DataFrame using the pd.DataFrame()
# (2) Function to_csv() is called to write into person.csv
import pandas as pd

# Creating a data frame
df = pd.DataFrame([['Di Renjie', 'Detective'], ['Su Wuming', 'Detective']], columns = ['Name', 'Profession'])

# Writing data frame to a CSV file
df.to_csv('person.csv')

19/07/2024

# Write to CSV files with Python

import csv
with open("GameOfThrones.csv", "w", newline="") as file:
    writer = csv.writer(file)
    writer.writerow(["Name", "HouseOf"])
    writer.writerow(["Ned Stark", "Stark"])
    writer.writerow(["Tywin Lannister", "Lannister"])
    writer.writerow(["Robert Baratheon", "Baratheon"])

18/07/2024

# Error handling
# I can't open my file in Downloads. So I wrote a error handling for that.
import csv

file_path  = r"C:\Users\sebwa\Downloads\people.csv"

try:
    with open(file_path, "r") as file:
        reader = csv.reader(file)

        for row in reader:
            print(row)
except FileNotFoundError:
    print(f"Error: The file at {file_path} was not found.")
except PermissionError:
    print(f"Error: Permission denied when trying to open the file at {file_path}")
except Exception as e:
    print(f"An unexpected error occured: {e}")

17/07/2024

# Parse JSON string to Python
import json

# Some JSON
x =  '{ "name":"Sebastien", "age":27, "city":"Paris"}'

# Parse x
y = json.loads(x)

# The result is a Python dictionary
print(y["age"])

16/07/2024

# math.ceil()
import math

x = math.ceil(1.4)
y = math.floor(1.4)

print(x)
print(y)

15/07/2024

# Built-in Math Functions
# min() and max() functions to find lower or higher value in an iterable
x = min(5, 10, 34, 2, 87, 65, 3, 6, 0, 15, 9, 4, 1, 56, 88, 79, 69)
y = max(5, 10, 34, 2, 87, 65, 3, 6, 0, 15, 9, 4, 1, 56, 88, 79, 69)

print(x)
print(y)

14/07/2024

# lambda
# Add 10 to argument a, and return the result
x = lambda a: a + 10
print(x(5))

13/07/2024

# Recursive function
# Below is a recursive function to find the factorial of an integer
# factorial() is a recursive function as it calls itself
# Ex: factorial of 6 is 1*2*3*4*5*6 = 720
def factorial(n):

    if n == 1:
        return 1
    else:
        return(n * factorial(n-1))

num = 6
print(f"The factorial of {num} is {factorial(num)}.")

12/07/2024

# Library function using math
# sqrt() ==> return square root number
# pow() ==> return power of number
import math

square_root = math.sqrt(4)
print("Square root of 4 is", square_root)

power = pow(2, 3)
print("2 to the power 3 is", power)

11/07/2024

# Stack = linear data structure
# append() function to push

stack = []
stack.append('a')
stack.append('b')
stack.append('c')

print("Initial stack: ", stack)

print("\nElements popped from the stack: ", stack.pop())

print("\nStack after elements are popped: ", stack)

10/07/2024

# Create a new file using the open() method
# 'x' == create a file, returns an error if the file exists
f = open("test2.txt", "x")

09/07/2024

# Ex: open and read the file after the overwriting
f = open("test2.txt", "r")
print(f.read())

08/07/2024

# Ex: open the file 'test2.txt' and overwrite the content
f = open("test2.txt", "w")
f.write("Oopsie! I have delete the content!")
f.close()

07/07/2024

# To write to an existing file, you must add a parameter to the open() function
# 'a' == append to end of file
# 'w' == overwrite any existing content
# 'x' == create a new file, returns an error if file already exists
# Ex: open the file "test.txt" and append content to the file
f = open("test.txt", "a")
f.write("Now the file has more content!")
f.close()

# Open and read the file after appending
f = open("test.txt", "r")

06/07/2024

# Tuple with one item
thistuple = ("apple",)
print(type(thistuple))

thistuple = ("apple")
print(type(thistuple))

----------------------------------------------------------------------------------------------------------------------------

# Tuples are immutable.
# How to remove an item from it?

# You can do this by converting the tuple to the list.
# Then convert the list back to a tuple.
Tuple = ("Pyongyang", "Paris", "Beijing,", "Tokyo")
List = list(Tuple)
List.remove("Paris")
Tuple = tuple(List)
print(Tuple)

----------------------------------------------------------------------------------------------------------------------------

# Unpacking in tuple
# When we create a tuple, we normally assign values to it. This is called "packing" a tuple.
# In Python, we are also allowed to extract values back into variables. It's called "unpacking".
chineseZodiac = ("rat", "dragon", "tiger", "rabbit")
(smart, majestic, fierce, agile) = chineseZodiac
print(smart)
print(majestic)
print(fierce)
print(agile)

# If the number of variables is less than the number of values, you can add * to the variable name and the values will be assigned to the variable as a list.
fruits = ("apple", "banana", "strawberry", "raspberry", "cherry")
(green, yellow, *red) = fruits
print(green)
print(yellow)
print(red)


05/07/2024

# Tuples are immutable.
# Is there a workaround to alter its value?

# You can do this by converting the tuple to the list.
# Then convert the list back to a tuple.
Tuple = ("Pyongyang", "Paris", "Beijing,", "Tokyo")
List = list(Tuple)
List[1] = "Seoul"
Tuple = tuple(List)
print(Tuple)

04/07/2024

# Concatenate two tuples
tuple1 = ("apple", "banana", "cherry", "strawberry")
tuple2 = ("orange", "ananas",)
tuple1 += tuple2
print(tuple1)

03/07/2024

# Exception handling
x = int(input("Enter a number: "))
if x < 0:
    raise Exception("Sorry, no numbers below zero.")

----------------------------------------------------------------------------------------------------------------------------

x = "hello"
if not type(x) is int:
    raise TypeError("Only Integer are allowed.")

02/07/2024

# Understanding string format()
# Use of index numbers {} to be sure the values are in correct placeholders
# Use of '{:.2f}' to display numbers with two decimals
quantity = 3
itemno = 567
price = 51
myorder = "I want {0} pieces of item number {1} for {2:.2f} dollars."
print(myorder.format(quantity, itemno, price))

01/07/2024

# Making a terminal progress bar using 'tqdm'
from tqdm import tqdm
from time import sleep

for i in tqdm(range(0, 100), ncols = 100, desc = "Hacking in progression"):
    sleep(.5)

print("Hacking successful.")

30/06/2024

# Understanding what is an 'argument'
# We passed "Sebastien" as an argument
def greet(name):
    print("Hello", name)

greet("Sebastien") 

----------------------------------------------------------------------------------------------------------------------------

# Understanding what is an 'argument'
# Function with two arguments: num1 and num2
def add_numbers(num1, num2):
    sum = num1 + num2
    print(sum)

add_numbers(3, 2)

----------------------------------------------------------------------------------------------------------------------------

# Function VS Function with return statement
# The main advantage of using the return method in the function is that it allows the result to be used outside the function
def add_numbers(num1, num2):
    sum = num1 + num2
    print(sum)

add_numbers(3, 2)


def add_numbers(num1, num2):
    sum = num1 + num2
    return sum # return denotes that the function has ended

result = add_numbers(3, 2)
print(result)


29/06/2024

# Understanding optional parameters for Class
class Dog:
    def __init__(self, dogbreed = "German Shepherd", dogeyecolor = "brown"):
    # two optional parameters:
    # dogbreed with default value "German Shepherd"
    # dogeyecolor with default value "brown"

        self.breed = dogbreed # self.breed = instance variable | dogbreed = value
        self.eyecolor = dogeyecolor

tomita = Dog("Chihuahua", "brown")
rex = Dog() # use the default values ("German Shepherd", "brown") for the parameters since no arguments are provided

print(tomita.breed, tomita.eyecolor)
print(rex.breed, rex.eyecolor)

28/06/2024

# Three ways to join list 
# (1) + operator
# (2) append() 
# (3) extend() 

list1 = ["a", "b", "c"]
list2 = [1, 2, 3]
list3 = list1 + list2
print(list3)

list1 = ["a", "b" , "c"]
list2 = [1, 2, 3]
for x in list2:
    list1.append(x)
print(list1)

list1 = ["a", "b" , "c"]
list2 = [1, 2, 3]
list1.extend(list2)
print(list1)

----------------------------------------------------------------------------------------------------------------------------

# Replacing 'self' with different names to understand its mechanism..
class Person:
  def __init__(mysillyobject, name, age):
    mysillyobject.name = name
    mysillyobject.age = age

  def myfunc(abc):
      print("Hello my name is " + abc.name)

  def myfunc2(abc2):
    print(f"I'm {abc2.age} years old.")

p1 = Person("Sebastien", 27)

p1.myfunc()
p1.myfunc2()

----------------------------------------------------------------------------------------------------------------------------

# INHERITANCE
class Person:
    def __init__(self, fname, lname):
        self.firstname = fname
        self.lastname = lname

    def printname(self):
        print(f"My firstname is {self.firstname} and my last name is {self.lastname}.")

x = Person("Sebastien", "HOBERT")
# x.printname()

class Friend(Person):
    def __init__(self, fname, lname, yearLivedInChina):
        super().__init__(fname, lname)
        self.YearLivedInChina = yearLivedInChina

    def welcome(self):
        print(f"I'm {self.firstname} {self.lastname} and I lived in China in {self.YearLivedInChina}.")

x = Friend("Aimie", "APARISI", 2023)
# x.printname()

x.welcome()


27/06/2024

# insert()
# insert ananas in 3rd position the list
thislist = ["ananas", "apple", "cherry"]
thislist.insert(2, "banana")
print(thislist)

----------------------------------------------------------------------------------------------------------------------------

# range()
# Print the following list ==> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
list = [x for x in range(10)]
print(list)

# range()
# Print the following list ==> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] but accept only numbers lower than 5
list = [x for x in range(10) if x < 5]
print(list)

----------------------------------------------------------------------------------------------------------------------------

# for == iteration keyword
# (1) Start a "for" loop that iterates over the numbers from 0 to 9 (10 exclusive)
# In each iteration, the variable i takes on the next value in the range
# (2) Print the current value of i followed by a space, without moving to the next line
# (3) Check if the current value of i is equal to 6
# (4) If the condition i == 6 is true, execute "break" statement, which immediately exits the loop
# (5) Print a newline character, moving the cursor to the next line
# The print statement is outside the loop, so it is executed after the loop has completed or after the loop has been terminated by the break statement
# Expected result: 0 1 2 3 4 5 6 
for i in range(10):
    print(i, end=" ")
    if i == 6:
        break
print()

----------------------------------------------------------------------------------------------------------------------------

# while == iteration keyword
# (1) Initialize a variable i with value 0
# (2) Start a "while" loop that continues executing as long as i < 10 is true
# (3) If i == 6 is true, increment i by 1
# (4) Set "continue" statement so the control go back to the beginning of the loop without executing the remaining code
# (5) If i == 6 is false, create an "else" block within which we print the current value of i separated by space
# (6) Increment the value by 1
# Expected result: 0 1 2 3 4 5 7 8 9
i = 0
while i < 10:
    if i == 6:
        i += 1
        continue
    else:
        print(i, end=" ")
        i += 1

----------------------------------------------------------------------------------------------------------------------------

# iter() == iterable
# Return an iterator from a tuple and print each value
fruits = ("apple", "banana", "cherry")
my_iterable = iter(fruits)
print(next(my_iterable))
print(next(my_iterable))
print(next(my_iterable))

----------------------------------------------------------------------------------------------------------------------------

# __iter__() and __next__() == create an object/class as iterator
# All classes have a function __init__() which allows to do initializing when the method is created
# The __iter__() method acts similar, you can do operations (initialising etc.) but must always return the iterator object itself
# The __next__() method also allows you to do operations, and must return the next item in the sequence
# (1) Create an iterator that returns numbers starting with 1, and each sequence will increase by one (returning 1,2,3,4) etc.
# Expected result:
# 1
# 2
# 3
# 4
class MyNumbers:
    def __iter__(self):
        self.a = 1  # Initializes an instance attribute 'a'
        return self  # Returns the iterator object itself

    def __next__(self):
        x = self.a  # Accesses the instance attribute 'a'
        self.a += 1  # Increments the instance attribute 'a'
        return x  # Returns the current value of 'a' before incrementing

myclass = MyNumbers() # Create an instance of MyNumbers
iterator = iter(myclass) # Get an iterator from the instance

print(next(iterator)) # Output: 1
print(next(iterator)) # Output: 2
print(next(iterator)) # Output: 3
print(next(iterator)) # Output: 4

26/06/2024

# In this example, tri_recursion() is a function that we have defined to call itself ("recurse")
# We use the k variable as a data, which decrements (-1) every time we recurse
# The recursion ends when the condition is not greater than 0 (i.e. when it is 0)
def tri_recursion(k):
    if (k > 0):
        result = k + tri_recursion(k - 1)
        print(result)
    else:
        result = 0
    return result
print("Results:")
tri_recursion(5)

----------------------------------------------------------------------------------------------------------------------------

# CREATE A PARENT CLASS
# Create a class named Person with firstname and lastname properties, and a printname method
# Use the Person class to create an object, then execute the printname method
class Person:
    def __init__(self, fname, lname):
        self.firstname = fname
        self.lastname = lname

    def printname(self):
        print(self.firstname, self.lastname)

x = Person("Sebastien", "HOBERT")
x.printname()

25/06/2024

# To let a function return a value, use the return statement
def func(x):
    return 5 * x
print(func(1))
print(func(5))
print(func(10))

24/06/2024

# Passing a list as an argument
# You can send any data types of argument to a function (string, number, list, dictionary..)
# It will be treated as the same data type inside the function
# Ex: if you send a list as an argument, it will still be a list when it reaches the function
def function(food):
    for x in food:
        print(x)
fruits = ["banana", "cherry", "ananas"]
function(fruits)

23/06/2024

# Arbitrary keyword arguments **kwargs
# If you don't know how many keyword arguments will be passed into your function, add ** before the parameter name in the function definition
# This way the function will receive a dictionary of arguments, and can access the items accordingly
# Ex: if the number of keyword arguments is unknown, add a ** before the parameter number
def genshin_impact(**character):
    print(character["name2"] + " is a five-star character.")
genshin_impact(name1 = "Qiqi", name2 = "Keqing")

22/06/2024

# Keyword Arguments
# You can also send arguments with the key = value syntax
# This way the order of the arguments does not matter
def pokemon(pok1, pok2, pok3):
    print("The most popular starter from gen1 is " + pok3)
pokemon(pok1 = "bulbasaur", pok2 = "squirtle", pok3 = "charmander")

21/06/2024

def func(*character):
    print("This is one of the main characters from Hierarchy (kdrama) ==> ", character[4])
func("He-ra", "Woo-jin", "Jae-i", "Ri-an", "Kang Ha")

20/06/2024

def func(*pokemon):
    print("This Pokemon is water type ==> " + pokemon[2])
func("Blastoise", "Squirtle", "Suicune", "Lapras")

19/06/2024

# *args (arbitrary arguments)
# If you don't know how many arguments will be passed into your function
# Add * before the parameter name in the function
# This way the function will receive a tuple of arguments and can access the item accordingly
def func (*pokemon):
    print("The most powerful Pokemon is " + pokemon[0])
func("Metagross", "Pikachu", "Celebi", "Giratina", "Mew")

18/06/2024

# An argument is the value that is sent to the function when it is called
# By default, a function must be called with the correct number of arguments
# So if your functions expects two arguments, you have to call the function with two arguments
def my_function(fname, lname):
    print(fname + " " + lname)
my_function("Nana Ouyang", "Beverly Zhu")

17/06/2024

# Parameters vs Arguments
# They can be used for the same thing: information that are passed into a function

# From a function perspective:
# - Parameter is a variable listed inside the () in the function definition
# - Argument is the value that is sent to the function when it is called

16/06/2024

def my_function(fname):
    print(fname + " from daily Chinese vocabulary")
my_function("完善")
my_function("在乎")
my_function("意图")
my_function("责备")
my_function("思维")
my_function("租赁")

15/06/2024

def my_function(fname):
    print(fname + " from Polygram Karaoke")
my_function("Vivian Chow")
my_function("Jackie Cheung")

14/06/2024

def my_function(fname):
    print(fname + " from Strange Tales of Tang Dynasty")
my_function("Lu Linfeng")
my_function("Su Wuming")

13/06/2024

# Arguments
# The following example has a function with one argument (fname)
# When the function is called, we pass along a first name, which is used inside the function to print the full name
def my_function(fname):
    print(fname + " from Three Kingdoms")
my_function("Liu Bei")
my_function("Cao Cao")
my_function("Sun Jian")

12/06/2024

# Call a function
def my_function():
    print("Hello from a function!")
my_function()

11/06/2024

quantity = 1600
price = 8
myorder = "I want {} yuan at {} euros."
print(myorder.format(quantity, price))

10/06/2024

# format() method
age = 27
txt = "My name is Sebastien and I am {}"
print(txt.format(age))

09/06/2024

# A nested loop is a loop inside a loop
# The inner loop will be executed one time for each iteration of the outer loop
# Ex: print each adjective for every fruit
adj = ["big", "tasty"]
fruits = ["apple", "ananas"]
for x in adj:
    for y in fruits:
        print(x, y)

08/06/2024

# The "else" block will not be executed if the loop is stopped by a break statement
for x in range(6):
    if x == 3: break
    print(x)
else:
    print("Finally finished!")

04/06/2024

# The "else" keyword in a "for" loop specifies a block of code to be executed when the loop is finished
# Ex: print all numbers from 0 to 5, and print a message when the loop has ended
for x in range(6):
    print(x)
else:
    print("All numbers have been printed.")

03/06/2024

for x in range (1, 40, 5):
    print(x)

02/06/2024

for x in range(1, 6):
    print(x)

01/06/2024

# range() function to loop through a set of code a specified number of time
for x in range(6):
    print(x)

31/05/2024

# With the continue statement we can stop the current iteration of the loop and continue with the next
fruits = ["apple", "banana", "cherry"]
for x in fruits:
    if x == "banana":
        continue
    print(x)

30/05/2024

# Exit the loop when x is "banana", but this time the break comes before the print
fruits = ["apple", "banana", "cherry"]
for x in fruits:
    if x == "banana":
        break
    print(x)

29/05/2024

# With the break statement we can stop the loop before it has looped through all items
# Ex: exit the loop when x is "banana"
fruits = ["apple", "banana", "cherry"]
for x in fruits:
    print(x)
    if x == "banana":
        break

28/05/2024

# for loop is used for iterating over a sequence (list, tuple, set, dictionary, string)
# Ex: loop through the letters in the word "banana"
for x in "banana":
    print(x)

27/05/2024

list1 = ["banana", "clementine"]
list2 = ["chocolat", "cereal"]
list1.extend(list2)
print(list1)

# You can add any iterable object (tuples, sets, dictionaries, etc.)
fruits = ["orange", "kiwi"]
dairy = ("milk", "yogurt")
fruits.extend(dairy)
print(fruits)

26/05/2024

# The clear() method empties the dictionary
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
print(ChineseEV)
ChineseEV.clear()
print(ChineseEV)

24/05/2024

# The popitem() method removes the last inserted item
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
ChineseEV.popitem()
print(ChineseEV)

23/05/2024

# pop() method to remove the item with a key name
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
ChineseEV.pop("year")
print(ChineseEV)

22/05/2024

# To access items from a nested dictionary, you use the name of the dictionaries, starting with the outer dictionary
myFriendsandI = {
    "person1" : {
        "name" : "Sebastien",
        "year" : 1996
    },
    "person2" : {
        "name" : "Jean-Paul",
        "year" : 1985
    },
    "person3" : {
        "name" : "Clara",
        "year" : 1997
    }
}
print(myFriendsandI["person3"]["year"])

21/05/2024

# Nested dictionary
# Create three dictionaries, then create one dictionary that will contain them
person1 = {
    "name" : "Sebastien",
    "year" : 1996
    }
person2 = {
    "name" : "Jean-Paul",
    "year" : 1985
    }
person3 = {
    "name" : "Josephine",
    "year" : 1997
    }

personDictionary = {
    "person1" : person1,
    "person2" : person2,
    "person3" : person3
}

print(personDictionary)

20/05/2024

# Nested dictionary
# Create a dictionary that contains three dictionaries
myFriendsandI = {
    "person1" : {
        "name" : "Sebastien",
        "year" : 1996
    },
    "person2" : {
        "name" : "Jean-Paul",
        "year" : 1985
    },
    "person3" : {
        "name" : "Clara",
        "year" : 1997
    }
}
print(myFriendsandI)

19/05/2024

# You can use the keys() method to return the keys of a dictionary
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
for x in ChineseEV.keys():
  print(x)


# Loop through both keys and values, by using the items() method
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
for x in ChineseEV.items():
  print(x)

18/05/2024

# You can use the values() method to return values of a dictionary
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
for x in ChineseEV.values():
    print(x)

17/05/2024

# Loop dictionary
# When looping through a dictionary, the return value are the keys of the dictionary
# But there are methods to return the values as well
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
for x in ChineseEV:
    print(x)


# Print all values in the dictionary, one by one:
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
for x in ChineseEV:
    print(ChineseEV[x])

16/05/2024

# Copy a dictionary
# You cannot copy a dictionary simply by typing dict2 = dict1
# Because dict2 will only be a reference to dict1
# And change made to in dict1 will automatically also be made in dict2
# There are ways to make a copy, one way is to use the built-in Dictionary method copy()
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
ChineseEV2 = ChineseEV.copy()
print(ChineseEV2)

# Another way to make a copy is to use the built-in function dict()
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
ChineseEV_2 = dict(ChineseEV)
print(ChineseEV_2)

15/05/2024

# update()
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
ChineseEV.update({"year":2023})
print(ChineseEV)

14/05/2024

# Change values
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
ChineseEV["year"] = 2023
print(ChineseEV)

13/05/2024

# Update dictionary
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
ChineseEV["color"] = "blue"
print(ChineseEV)
ChineseEV.update({"price": 29900})
print(ChineseEV)

12/05/2024

# Adding an item to the dictionary is done by using a new index key and assigning a value to it
ChineseEV = {
  "brand": "Xiaomi",
  "model": "SU7",
  "year": 2024
}
ChineseEV["color"] = "blue"
print(ChineseEV)

11/05/2024

# To determine if a specified key is present in a dictionary use the in keyword
# Check if "model" is present in the dictionary
car = {
    "brand": "Nio",
    "model": "ET7",
    "price": 69200,
    "year": 2022,
}
if "model" in car:
    print("Yes, 'model' is one of the keys in the car dictionary.")

10/05/2024

car = {
    "brand": "Nio",
    "model": "ET7",
    "price": 69200,
    "year": 2022,
}
x = car.items()
print(x)
car["year"] = 2023
print(x)

09/05/2024

# Add a new item to the original dictionary, and see that the values list gets updated as well
car = {
    "brand": "Nio",
    "model": "ET7",
    "price": 69200,
    "year": 2022,
}
x = car.values()
print(x)
car["power in KW"] = 480
print(x) # After the change 

08/05/2024

car = {
    "brand": "Nio",
    "model": "ET7",
    "price": 69200,
    "year": 2022,
}
x = car.values()
print(x) # Before the change
car["year"] = 2023
print(x) # After the change

07/05/2024

# Get a list of values
japaneseCar = {
    "brand": "Toyota",
    "model": "Prius",
    "year": "2011"
}
x = japaneseCar.values()
print(x)

06/05/2024

# Add a new item to the original dictionary, and see that the keys list gets updated as well
japaneseCar = {
    "brand": "Toyota",
    "model": "Prius",
    "year": "2011"
}
x = japaneseCar.keys()
print(x)
japaneseCar["price"] = 25,000
print(x)

04/05/2024

# The keys() method will return a list of all keys in the dictionary
# Get a list of keys
japaneseCar = {
    "brand": "Toyota",
    "model": "Prius",
    "year": "2011"
}
x = japaneseCar.keys()

03/05/2024

# Get the value of the "model" key
thisdict = {
    "brand": "Toyota",
    "model": "Prius",
    "year": 2011
}
x = thisdict.get("model")
print(x)

02/05/2024

def encrypt(key, plaintext):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    encrypted_text = ""

    for char in plaintext:
        if char.isalpha():
            shifted_index = (alphabet.index(char) + key) % 26
            encrypted_text += alphabet[shifted_index]
        else:
            encrypted_text += char

    return encrypted_text

plaintext = "strange tales of tang dynasty"
key = 1
encrypted_text = encrypt(key, plaintext)
print("Encrypted:", encrypted_text)

01/05/2024

def encrypt(key, plaintext):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    encrypted_txt = ""

    for char in plaintext:
        if char.isalpha():
            shifted_index = (alphabet.index(char) + key) % 26
            encrypted_txt += alphabet[shifted_index]
        else:
            encrypted_txt += char
            
            #return encrypted_txt ===> return only letter "l"
    return encrypted_txt

# TEST
plaintext = "kampot"
print("Plaintext is:", plaintext)
key = 1
encrypted_txt = encrypt(key, plaintext)
print("Encrypted text is: ", encrypted_txt)

30/04/2024

"""
  3. Ecrire une fonction encrypt qui prend en paramètre un entier key et une chaîne de
caractères plaintext et qui renvoie le plaintext avec chacune des lettres décalées
de key position dans l’alphabet. Dans un premier temps, le mot plaintext ne
contient que des lettres minuscules. Tester votre fonction.
"""

def encrypt(key, plaintext):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    encrypted_text = ""

    for char in plaintext:
        if char.isalpha():
            shifted_index = (alphabet.index(char) + key) % 26
            encrypted_text += alphabet[shifted_index]
        else:
            encrypted_text += char

    return encrypted_text

# Test of function
plaintext = "sebastien"
print("- Plaintext:", plaintext)
key = 1
encrypted_text = encrypt(key, plaintext)
print("- Encrypted text:", encrypted_text)

"""
 4. Ecrire la fonction de déchiffrement decrypt correspondante (de même, elle prend
en entrée un entier key et une chaine ciphertext et renvoie le plaintext correspondant) et la tester sur quelques exemples.
"""

def decrypt(key, ciphertext):
    return encrypt(-key, ciphertext)

# Test of function
plaintext = "sebastien"
decrypted_text = decrypt(key, encrypted_text)
print("- Decrypted text:", decrypted_text)

"""
5. Comment attaquer facilement ce chiffrement ? Retrouver le clair correspondant à la
valeur ciphertext dans cesar.py.
"""
ciphertext = "gz xcdaamzhzio kvm yzxvgvbz zno avdwgz!"

def decrypt(ciphertext, key):
    decrypted_text = ""
    for char in ciphertext:
        if char.isalpha():
            decrypted_text += chr(((ord(char) - ord('a') - key) % 26) + ord('a'))
        else:
            decrypted_text += char
    return decrypted_text

def attack(ciphertext):
    for key in range(25):
        decrypted_text = decrypt(ciphertext, key)
        print(f"Hacking en cours ... tentative == {key}: {decrypted_text}")

attack(ciphertext)

29/04/2024

def encrypt(key, plaintext):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    encrypted_text = ""

    for char in plaintext:
        if char.islower():
            shifted_index = (alphabet.index(char) + key) % 26
            encrypted_text += alphabet[shifted_index]
        else:
            encrypted_text += char

    return encrypted_text

def decrypt(key, ciphertext):
    return encrypt(-key, ciphertext)

# Example usage
plaintext = "hello world"
key = 3
encrypted_text = encrypt(key, plaintext)
print("Encrypted:", encrypted_text)

decrypted_text = decrypt(key, encrypted_text)
print("Decrypted:", decrypted_text)

28/04/2024

# Accessing Items
# Ex: get the value of the "model" key
thisdict = {
    "brand": "Nio",
    "model": "ET7",
    "year": 2022
}
x = (thisdict["model"])

27/04/2024

# dict() constructor
carDictionnary = dict(brand="xpeng", model="p7", year="2020")
print(carDictionnary)

26/04/2024

# Print the "brand" value of the dictionnary
carDictionnary = {
    "brand": "BYD",
    "model": "Seal U",
    "year": "2024"
}
print(carDictionnary["brand"])

25/04/2024

Dict = {1: 'China', 2: 'Japan', 3: 'South Korea', 4: 'North Korea'}
print(Dict)
print(Dict[1])

24/04/2024

# GENERATE RANDOM NUMBER
# Ex: generate a random integer from 0 to 100
from numpy import random
x = random.randint(100)
print(x)

# GENERATE RANDOM FLOAT (0 to 1)
# The random module's rand() method returns a random float between 0 and 1
# Ex: generate a random float from 0 to 1
from numpy import random
x = random.rand()
print(x)

# RANDOM DISTRIBUTION
# Ex: return one of the values in an array
from numpy import random
x = random.choice([3, 5, 7, 8, 9])
print(x)

# RANDOM DISTRIBUTION
# The choice() method allows us to specify the probability for each value
# The probability is set by a number between 0 and 1
from numpy import random
x = random.choice([5, 2, 8 ,1], p=[0.1, 0.1, 0.7, 0.1], size=100)
print(x)

# Ex: same example, but return a 2-D array with 3 rows, each containing 5 values
from numpy import random
x = random.choice([3, 8, 4, 3], p=[0.1, 0.7, 0.1, 0.1], size=(3, 5))
print(x)

23/04/2024

# Numpy is used to work with arrays
# The array object in NumPy is called "ndarray"
# Ex: create a numpy array
import numpy as np
arr = np.array([1, 2, 3, 4, 5])
print(arr)
print(type(arr))

22/04/2024

x = "awesome"
def myfunc():
    x = "awful"
    print("I think this is " + x)
myfunc()

# Normally, when you create a variable inside a function, that variable is local and can only be used inside that function
# To create a global variable inside a function, you can use the global keyword
x = "awesome"
def myfunc():
    global x
    x = "awful"
    print("I think this is " + x)
myfunc()
print("I think this is " + x)


21/04/2024

# Delete folder
# To delete an entire folder, use the os.rmdir() method
# Remove the folder "test"
import os
os.rmdir("test")

20/04/2024

# Check if files exists
# To avoid getting an error you might want to check if the file exists before you try to delete it
# Ex: check if the files exists, then delete it
import os
if os.path.exists("test.txt"):
    os.remove("test.txt")
else:
    print("The file does not exit.")

19/04/2024

# To delete a file, you must import the OS module, and run its os.remove() function
# Ex : remove the file "test.txt"
import os
os.remove("test.txt")

18/04/2024

# The strftime() method
# The datetime object has a method for formatting date objects into readable strings
# The method is called strftime(), and takes one parameter, format, to specify the format of the returned string
# Ex: Display the name of the month

import datetime
x = datetime.datetime(2024, 4, 18)
print(x.strftime("%B"))
# print(x)

17/04/2024

# To create a date
# We can use datetime() class constructor of datetime module
# Ex: create a date object
import datetime
x = datetime.datetime(2024, 4, 17)
print(x)

16/04/2024

# Return the year and name of weekday
import datetime
x = datetime.datetime.now()
print(x.year)
print(x.strftime("%A"))

15/04/2024

# Import the datetime module and display the current date
import datetime
x = datetime.datetime.now()
print(x)

14/04/2024

word = "The Epic Version of Strange Tales of Tang Dynasty"
counter = {}

for letter in word:
    if letter not in counter:
        counter[letter] = 0
    counter[letter] +=1

print(counter)

13/04/2024 (past midnight)

word = "mississippi"
counter = {}

for letter in word:
    if letter not in counter:
        counter[letter] = 0
    counter[letter] += 1

print(counter)

12/04/2024

# Convert string to boolean
string = "Strange Tales of Tang Dynasty"
boolean_value = bool(string)
print(boolean_value)
print(type(boolean_value))

11/04/2024 (past midnight)

class Language:
    def __init__(self, chinese):
        self.chinese = chinese

    def __len__(self):
        return len(self.chinese)

voc = Language("拘留")
print(len(voc))

10/04/2024

class Language:
    def __init__(self, chinese):
        self.chinese = chinese
    def __len__(self):
        return len(self.chinese)

voc = Language("破例")
print(len(voc))

09/04/2024

class Language:
    def __init__(self, chinese):
        self.chinese = chinese
    def __len__(self):
        return len(self.chinese)

vocabulary = Language("各个击破")
print(len(vocabulary))

08/04/2024

class language:
    def __init__(self, chinese):
        self.chinese = chinese
    def __len__(self):
        return len(self.chinese)

voc = language("香消玉殒xiāngxiāoyùyǔn")
print(len(voc))

07/04/2024

# It doesn't have to be named self
# But it has to be the first parameter of any function in the class
class Language:
    def __init__(lang, chinese, english):
        lang.chinese = chinese
        lang.english = english

    def myfunc(l):
        print(l.chinese + " in English can be translated as: " + l.english)

word1 = Language("适逢", "to just happen to coincidence with")
word2 = Language("占", "to occupy (rank, land..)")
word3 = Language("打手势", "to make a gesture")

word2.myfunc()


# You can modify properties on objects like this
word2.english = "to seize"
word2.myfunc()

06/04/2024

class Dict:
    def __init__(self, chinese, english):
        self.chinese = chinese
        self.english = english

    def func(self):
        print(self.chinese + " means " + self.english)

voc1 = Dict("涌现", "emerge in large numbers")
voc2 = Dict("抛", "to dump")

voc1.func()

05/04/2024

class Words:
    def __init__(self, english, chinese):
        self.english = english
        self.chinese = chinese

    def myFunc(self):
        print(self.english + " in Chinese is: " + self.chinese)

voc1 = Words("comb", "梳子")
voc2 = Words("to fall down", "坠")
voc3 = Words("prejudice", "偏见")

voc2.myFunc()

04/04/2024

class Language:
    def __init__(self, chinese, english):
        self.english = english
        self.chinese = chinese

    def MyFunc(self):
        print(self.chinese + " can be translated by " + self.english)

Voc1 = Language("幻象", "illusion")
Voc2 = Language("攀", "to climb")
Voc3 = Language("鞭子", "whip")

Voc3.MyFunc()

03/04/2024

class vocabulary:
    def __init__(self, mandarin, english):
        self.mandarin = mandarin
        self.english = english

    def funct(self):
        print(self.mandarin + " in english is " + self.english)

voc1 = vocabulary("签证", "visa")
voc2 = vocabulary("轻", "light")
voc3 = vocabulary("缺少", "to be short of")
voc4 = vocabulary("却", "however")
voc5 = vocabulary("确实", "true")

voc1.funct()

02/04/2024

class language:
    def __init__(self, english, chinese):
        self.english = english
        self.chinese = chinese

    def func(self):
        print("Translation for " + self.english + " is " + self.chinese)

word1 = language("freedom of speech", "言论自由")
word2 = language("turbid water", "浊水")
word3 = language("hover in the air", "飞翔")

word2.func()

01/04/2024

class Vocabulary:
    def __init__(self, chinese, english):
        self.chinese = chinese
        self.english = english

    def function(self):
        print("The translation for " + self.chinese + " is: " + self.english)

character1 = Vocabulary("农", "Thick")
character2 = Vocabulary("戒指", "Finger ring")
character3 = Vocabulary("插", "To insert")
character4 = Vocabulary("沟渠", "Irrigation canal")
character5 = Vocabulary("袭击", "Surprise attack")

character3.function()

31/03/2024

# OBJECT METHOD
# Objects can also contain methods
# Methods in objects are functions that belong to the object
# Ex: insert a function that prints a greeting, and execute it on the p3 object
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def myfunc(self):
        print("Hello my name is " + self.name)

p1 = Person("Sebastien", 27)
p2 = Person("Clara", 26)
p3 = Person("Raphael", 33)

p3.myfunc()

30/03/2024

#Ex: the string representation of an object WITH the __str__() function
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def __str__(self):
        return f"{self.name}({self.age})"
p1 = Person("Sebastien", 27)
print(p1)

29/03/2024

# The __str__() function
# It controls what should be returned when the class object is represented as a string
# If the __str__() function is not set, the string representation of the object is returned
#Ex: the string representation of an object WITHOUT the __str__() function
class Person:
    def __init__(self, name, age):
        self.name = name
        self.name = age
p1 = Person("Sebastien", 27)
print(p1)

28/03/2024

# The __init__() function
# To understand classes we have to understand the built-in __init__() function
# All classes have a function called __init__() which is always executed when the class is being initiated
# Use the __init__() function to assign values to object properties, or other operations that are necessary to do when the object is being created

# Ex: create a class named Person, use the __init__() function to assign values for name and age
class Person:
    def __init__(self, name, age, city):
        self.name = name
        self.age = age
        self.city = city

p1 = Person("Sebastien", 27, "Paris")
p2 = Person("Nicole", 25, "London")

print(p1.name)
print(p1.age)
print(p1.city)

print(p2.name)
print(p2.age)
print(p2.city)

27/03/2024

# Python is an oriented programming language
# Almost everything in Python is an object, with its properties and methods
# A class is like an object constructor, or a blueprint for creating objects

# CREATE A CLASS
# Ex: create a class named Myclass with a property named x
class Myclass:
    x = 5

# CREATE AN OBJECT
# Now we can use the class named Myclass to create objects
# Ex: create an object named p1 and print the value of x
class Myclass:
    x = 5
p1 = Myclass()
print(p1.x)

26/03/2024

# You can't copy a list simply by typing list2 = list1
# Because list2 will only be a reference to list1
# And change made in list1 will automatically also be made in list2
# There are ways to make a copy, one way is to use built-in List method copy()
thislist = ["apple", "banana", "cherry"]
thislist2 = thislist.copy()
print(thislist2)

# Another way to make a copy is to use the built-in method list()
fruits = ["apple", "banana", "cherry"]
fruits_copy = list(fruits)
print(fruits_copy)

25/03/2024

# Only accept items that are not "apple"
fruits = ["apple", "banana", "apple", "cherry", "kiwi", "mango"]
newlist = [x for x in fruits if x != "apple"]
print(newlist)

24/03/2024

# You can also use the remove() method to remove an element from an array
# Ex: Delete the element that has the value "Volvo"
cars = ["Ford", "Volvo", "BMW"]
cars.remove("Volvo")
print(cars)

23/03/2024

# Removing Array Elements
# You can use the pop() method to remove an element from the array
# Ex: delete the second element of the cars array
cars = ["BYD", "Toyota", "Hyundai"]
cars.pop(1)
print(cars)

22/03/2024

# Adding Array Elements
# You can use the append() method to add an element to an array
# Ex: add one more element to the cars array
cars = ["BYD", "Toyota", "Hyundai"]
cars.append("MG")
print(cars)

21/03/2024

# The length of an array
# Use the len() method to return the length of an array (no of element in an array)
# Ex : return the number of elements in the cars array:
cars = ["Ford", "Volvo", "BMW"]
x = len(cars)
print(x)

# Looping array elements
# You can use the "for in" loop to loop through all the elements of an array
# Ex: print each item in the cars array
cars = ["Toyota", "Mazda", "Kia", "BYD"]
for x in cars:
    print(x)

20/03/2024

# Arrays are used to store multiple values in one single variable
# Create an array containing car names:
cars = ["Toyota", "MG", "BYD"]

# What is an array?
# An array is a special variable, which can hold more than one value at a time
# If you have a list of items (ex: car names) storing the cars in a single variable could look like this
car1 = "Toyota"
car2 = "MG"
car3 = "BYD"

# However, what if you want to loop through the cars and find a specific one? and what if you had not 3 cars but 300?
# The solution is an array!
# An array can hold many values under a single name, and you can access the value by referring to an index number

# Access the elements of an array
# You refer to an array element by referring to the index number
# Ex: get the value of the first array item
cars = ["Toyota", "MG", "BYD"]
cars[0] = "BYD"
print(cars)

19/03/2024

# Access element at index 2
arr = [1, 2, 3, 4]
print(arr[2])

# Print "W" at index 7
a = "Hello, World!"
print(a[7])

18/03/2024

"""
----------------------------
Define function 'getInteger'
----------------------------
(1) Prompt the user to enter a number through the input() function
NOTE:
- the entered value is then converted to an INTEGER using int()
- the result is stored in the variable 'number'

(2) Finally, the function returns the entered integer

----------------------
Define function 'Main'
----------------------
(1) It calls the getInteger() function and assigns its return value to the variable 'output'
(2) It prints the value of 'output'

-----------------------------------
Use the special variable '__name__'
-----------------------------------
(1) It checks whether the script is being run as the main program (not imported as a module)
(2) If the condition is true, it calls the Main() function
NOTE:
- this is a common practice in Python to ensure that the code inside the Main() function is executed only when the script is run directly, not when it's imported as a module
"""
def getInteger():
    number = int(input("Enter a number: "))
    return number

def Main():
    output = getInteger()
    print(output)

if __name__=="__main__":
    Main()

17/03/2024

# Import a library called 'random' and print a random number between 1 to 100
# 'randrange' is a method
import random
print(random.randrange(1, 100))

16/03/2024

# Sort the list alphabetically
fruits = ["orange", "mango", "kiwi", "pineapple", "banana"]
fruits.sort()
print(fruits)

# Sort the list numerically
numbers = [100, 50, 65, 82, 23]
numbers.sort()
print(numbers)

# Sort the list descending
fruits = ["orange", "mango", "kiwi", "pineapple", "banana"]
fruits.sort(reverse=True)
print(fruits)

# Sort this list, but observe how capital letters are messing up the sort() method
fruits = ["banana", "Orange", "Kiwi", "cherry"]
fruits.sort()
print(fruits)

# Perform a case-insensitive sort of the list
fruits = ["banana", "Orange", "Kiwi", "cherry"]
fruits.sort(key = str.lower)
print(fruits)

# Reverse the order of the list items
fruits = ["banana", "Orange", "Kiwi", "cherry"]
fruits.reverse()

15/03/2024

# Delete the entire list
countries = ["france", "usa", "canada", "china", "japan", "south korea"]
del countries
print(countries)

# Clear the list content
countries = ["france", "usa", "canada", "china", "japan", "south korea"]
countries.clear()
print(countries)

14/03/2024

#Ex: remove the first item using keyword "del"
countries = ["france", "usa", "canada", "china", "japan", "south korea"]
del countries[0]
print(countries)

13/03/2024

#Ex: remove the last item
countries = ["france", "usa", "canada", "china", "japan", "south korea"]
countries.pop()
print(countries)

12/03/2024

#Ex: remove the first item
countries = ["france", "usa", "canada", "china", "japan", "south korea"]
countries.pop(0)
print(countries)

11/03/2024

#Ex: remove the first occurrence of "usa"
countries = ["france", "usa", "canada", "china", "japan", "usa", "south korea", "usa", "usa"]
countries.remove("usa")
print(countries)

10/03/2024

#Ex: remove "usa"
countries = ["france", "usa", "canada", "china", "japan", "south korea"]
countries.remove("usa")
print(countries)

09/03/2024

# Return "orange" instead of "banana"
fruits = ["apple", "banana", "cherry", "banana", "kiwi", "mango", "banana"]
newlist = [x if x != "banana" else "orange" for x in fruits]
print(newlist)

08/03/2024

# Set all values in the new list to "eleve"
coursdechinois = ["sebastien", "lysa", "alice", "francois", "sophie"]
coursdechinoisAllValuesToEleve = ["eleve" for x in coursdechinois]
print(coursdechinoisAllValuesToEleve)

07/03/2024

# Set the values in the new list to upper case
coursdechinois = ["sebastien", "lysa", "alice", "francois", "sophie"]
coursdechinoisMAJ = [x.upper() for x in coursdechinois]
print(coursdechinoisMAJ)

06/03/2024

# CLASS DEFINITION - Define a class named "Dog" with two class attributes, attr1 named mammal and attr2 named dog
# METHOD DEFINITION - Define a method named "fun" taking parameter self to represent instance of the class
# METHOD IMPLEMENTATION - Inside the method "fun", print the values of the class attributes by calling the method
# OBJECT CREATION - Create an instance of the "Dog" class and assign it to the variable "Roger"
# METHOD INVOCATION - Call the fun method of the Dog class on the Rodger object
class Dog:
    attr1 = "mammal"
    attr2 = "dog"
    def fun(self):
        print(self.attr1)
        print(self.attr2)
Rodger = Dog()
Rodger.fun()

# Print the value of the attribute attr1 for the object "Rodger"
print(Rodger.attr1)

05/03/2024

# Accept only numbers lower than 8
list = [x for x in range(10) if x < 8]
print(list)

04/03/2024

# Use the range() function to create an iterable (1, 2, 3, 4 .. to 9)
list = [x for x in range(10)]
print(list)

03/03/2024

# ITERATE KEYWORD - for
# Use "for" and declare range to ten
# Print i
# Break if i equals to six
# Print final result
for i in range(10):
    print(i,  end=" ")
    if i == 6:
        break
print()


# ITERATION KEYWORD - while
# Set i to zero
# Use "while" where i strictly inferior to ten
# If i is equal to six
# Increment by one
# Continue
# Else
# Print i
# Increment i 
i = 0
while i < 10:
    if i == 6:
        i += 1
        continue
    else:
        print(i, end = " ")
    i += 1

02/03/2024

# Display a new list containing only names with letter "a", but using list comprehension
# (With list comprehension, you can do this with one line of code)
coursdechinois = ["sebastien", "lysa", "alice", "francois", "sophie"]
coursdechinoisA = [x for x in coursdechinois if "i" in x]
print(coursdechinoisA)

01/03/2024

# Display a new list containing only names with letter "a", but using for loop
coursdechinois = ["sebastien", "lysa", "francois", "sophie"]
coursdechinoisA = []
for x in coursdechinois:
    if "a" in x:
        coursdechinoisA.append(x)
print(coursdechinoisA)

17/02/2024

# Use the range() function to create an iterable (1, 2, 3, 4 .. to 9)
list = [x for x in range(10)]
print(list)

15/02/2024

# Only accept items that are not "beisong"
coursdechinois = ["sebastien", "lysa", "alice", "francois", "sophie", "beisong"]
coursdechinoisOK = [x for x in coursdechinois if x != "beisong"]
print(coursdechinois)
print(coursdechinoisOK)

14/02/2024

# Display a new list containing only names with letter "o", but using list comprehension
# (With list comprehension, you can do this with one line of code)
coursdechinois = ["sebastien", "lysa", "alice", "francois", "sophie"]
coursdechinoisA = [x for x in coursdechinois if "o" in x]
print(coursdechinoisA)

13/02/2024

# Display a new list containing only names with letter "a", but using for loop
coursdechinois = ["sebastien", "lysa", "francois", "sophie"]
coursdechinoisA = []
for x in coursdechinois:
    if "a" in x:
        coursdechinoisA.append(x)
print(coursdechinoisA)

12/02/2024

# Print all items (list comprehension offering shortest syntax for looping through list)
iamnobody = ["zhangchulan", "fengbaobao", "wangye", "zhugeqing", "zhanglingyu"]
[print(x) for x in iamnobody]

11/02/2024

# Print all items, using a while loop to go through all the index numbers
iamnobody = ["zhangchulan", "fengbaobao", "wangye", "zhugeqing", "zhanglingyu"]
i = 0 # Start at zero
while i < (len(iamnobody)): # len() to determine length of list
    print(iamnobody[i]) # Loop through list items by referring to their indexes
    i = i + 1 # Remember to increase the index by 1 after each iteration

10/02/2024

# Print all items referring to their index number
iamnobody = ["zhangchulan", "fengbaobao", "wangye", "zhugeqing", "zhanglingyu"]
for i in range(len(iamnobody)): # The iterable created is [0, 1, 2, 3, 4]
    print(iamnobody[i])

09/02/2024

# Print all items in the list, one by one
iamnobody = ["zhangchulan", "fengbaobao", "wangye", "zhugeqing", "zhanglingyu"]
for x in iamnobody:
    print(x)

08/02/2024

# Join two list by extending
list1 = ["a", "b", "c"]
list2 = [1, 2, 3]
list1.extend(list2)
print(list1)

07/02/2024

# Join two lists by appending
list1 = ["a", "b", "c"]
list2 = [1, 2, 3]
for x in list2:
    list1.append(x)
print(list1)

06/02/2024

# Join two list
list1 = ["a", "b", "c"]
list2 = [1, 2, 3]
list3 = list1 + list2
print(list3)

05/02/2024

# Make a copy of a list with the copy() method
fruits = ["apple", "banana", "cherry"]
copyoffruits = fruits.copy()
print(copyoffruits)

# Make a copy of a list with the list() method
fruits = ["apple", "banana", "cherry"]
methodfruits = list(fruits)
print(methodfruits)

04/02/2024

# Add elements of a tuple to a list
list = ["square", "rectangle", "cube"]
tuple = ("circle", "oval", "disk")
list.extend(tuple)
print(list)

03/02/2024

# Add the elements of otherphones to chinesephones
chinesephones = ["huawei", "xiaomi", "oppo", "vivo"]
otherphones = ["apple", "samsung"]
chinesephones.extend(otherphones)
print(chinesephones)

02/02/2024

# Insert item as 3rd position
list = ["huawei", "xiaomi", "oppo", "vivo"]
list.insert(2, "samsung")
print(list)

01/02/2024

# Add item to the end of the list
list = ["gauffre", "pain", "gateau"]
list.append("galette")
print(list)

